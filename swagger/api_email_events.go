
/*
 * Edgenexus REST API
 *
 * EdgeADC REST Web Services User Guide
 *
 * API version: 4.2.3
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package swagger

import (
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

// Linger please
var (
	_ context.Context
)

type EmailEventsApiService service
/*
EmailEventsApiService Email events page data
This service is used to FETCH E-MAIL Events data, it uses one API structure.    EmailEvents_All: Used to get Email events setings.      The nodes of JSON received, contains the given information        SecurityCombo: This node contains options of security such as SSL and TLS.     CEERemoteEmailAddress: This node contains Email address for Send E-mail.     CEELocalEmailAddress: This node contains Return E-Mail address.     CEEMailServer: This node contains Host Address.     CEEPort: This node contains Port.     CEETimeout: This node contains Timeout.     CEEAuthorisationRequired: This node contains &#x27;1&#x27;, if authorization required.     CEESecurity: This node contains information of type of security such as SSL or TLS.     CEEMailServerLogon: This node contains Mail server account name     CEEEvIpServiceNoticeEnabled: This node have 1 if IP service notice enabled.      CEEEvIpServiceNoticeText: This node have ip service notice text.     CEEEvIpServiceAlertTextEnabled: This node have 1 if IP service alert text enabled.     CEEEvIpServiceAlertText: This node have ip service alert text.     CEEEvChannelNoticeEnabled: This node have 1 if VS notice enabled.      CEEEvChannelNoticeText: This node have VS notice text.     CEEEvChannelAlertEnabled: This node have 1 if VS alert text enabled.     CEEEvChannelAlertText: This node have VS alert text.     CEEEvContentServerNoticeEnabled: This node have 1 if real server notice enabled.      CEEEvContentServerNoticeText: This node have real server notice text.     CEEEvContentServerAlertEnabled: This node have 1 if real server alert text enabled.     CEEEvContentServerAlertText: This node have real server alert text.     CEEEvFlightPathEnabled: This node have 1 if flightpath notice enabled.      CEEEvFlightPathText: This node have flightpath notice text.     CEEGroupEnabled: This node have 1 if group notice enabled.      CEEGroupText: This node have group notice text.     CEEGroupTime: This node have group time.     CEEEvDiskSpaceEnabled: This node have 1 if disk space notice enabled.     CEEEvDiskSpaceText: This node have disk space notice text.     CEEEvLicenceRenevalEnabled: This node have 1 if Licence Reneval notice enabled.     CEEEvLicenceRenevalText: This node have Licence Reneval text.     CEEEvDiskSpacePercent: This node have disk space percentage.     CEEEvTestTempFile:     CEEEvTestProcessID:     CEEEvTestEndTime:     CEEEvTestStatus: 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return []EmaileventsAll
*/
func (a *EmailEventsApiService) GET17Get(ctx context.Context) ([]EmaileventsAll, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []EmaileventsAll
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/GET/17"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("GUID", key)
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []EmaileventsAll
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
EmailEventsApiService Email events test
This service is used to FETCH E-MAIL Events data, it uses one API structure.    EmailEvents_All: Used to get Email events setings.      The nodes of JSON received, contains the given information        SecurityCombo: This node contains options of security such as SSL and TLS.     CEERemoteEmailAddress: This node contains Email address for Send E-mail.     CEELocalEmailAddress: This node contains Return E-Mail address.     CEEMailServer: This node contains Host Address.     CEEPort: This node contains Port.     CEETimeout: This node contains Timeout.     CEEAuthorisationRequired: This node contains &#x27;1&#x27;, if authorization required.     CEESecurity: This node contains information of type of security such as SSL or TLS.     CEEMailServerLogon: This node contains Mail server account name     CEEEvIpServiceNoticeEnabled: This node have 1 if IP service notice enabled.      CEEEvIpServiceNoticeText: This node have ip service notice text.     CEEEvIpServiceAlertTextEnabled: This node have 1 if IP service alert text enabled.     CEEEvIpServiceAlertText: This node have ip service alert text.     CEEEvChannelNoticeEnabled: This node have 1 if VS notice enabled.      CEEEvChannelNoticeText: This node have VS notice text.     CEEEvChannelAlertEnabled: This node have 1 if VS alert text enabled.     CEEEvChannelAlertText: This node have VS alert text.     CEEEvContentServerNoticeEnabled: This node have 1 if real server notice enabled.      CEEEvContentServerNoticeText: This node have real server notice text.     CEEEvContentServerAlertEnabled: This node have 1 if real server alert text enabled.     CEEEvContentServerAlertText: This node have real server alert text.     CEEEvFlightPathEnabled: This node have 1 if flightpath notice enabled.      CEEEvFlightPathText: This node have flightpath notice text.     CEEGroupEnabled: This node have 1 if group notice enabled.      CEEGroupText: This node have group notice text.     CEEGroupTime: This node have group time.     CEEEvDiskSpaceEnabled: This node have 1 if disk space notice enabled.     CEEEvDiskSpaceText: This node have disk space notice text.     CEEEvLicenceRenevalEnabled: This node have 1 if Licence Reneval notice enabled.     CEEEvLicenceRenevalText: This node have Licence Reneval text.     CEEEvDiskSpacePercent: This node have disk space percentage.     CEEEvTestTempFile:     CEEEvTestProcessID:     CEEEvTestEndTime:     CEEEvTestStatus: 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return []EmaileventsAll
*/
func (a *EmailEventsApiService) GET17iAction9iType9CEETestPid38555CEETestEndtimeCEETestTempfilemailtestpi6QbdGet(ctx context.Context) ([]EmaileventsAll, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []EmaileventsAll
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/GET/17?iAction=9&iType=9&CEE_TestPid=38555&CEE_TestEndtime=&CEE_TestTempfile=mailtestpi6Qbd"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("GUID", key)
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []EmaileventsAll
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
EmailEventsApiService Update email event
This service is used to update email events detaiils, you have to send email events details, with POST request json.    JSON that needs to be sent as request payload, Should contains given information-        CEEAuthorisationRequired: set \&quot;true\&quot; if authorization required.     CEEEMailServerPassword: Mail server password.     CEELocalEmailAddress: E-Mail address.     CEEMailServer: Host Address.     CEEMailServerLogon: Mail server account name.     CEEPort: Port address.     CEERemoteEmailAddress: Email address for Send E-mail.     CEESecurity: security      CEETimeout: Timeout.     Test: set \&quot;true\&quot; if want to send test mail with update otherwise set \&quot;false\&quot; to only update. 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body Object that needs to be sent to the server
@return []EmaileventsAll
*/
func (a *EmailEventsApiService) POST17iAction1iType1Post(ctx context.Context, body UpdateEmailEvent) ([]EmaileventsAll, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []EmaileventsAll
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/POST/17?iAction=1&iType=1"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("GUID", key)
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []EmaileventsAll
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
EmailEventsApiService Notifications details
This service is used to update notifications details, you have to send notifications details, with POST request json.    JSON that needs to be sent as request payload, Should contains given information-        CEEEvChannelAlertEnabled: set \&quot;true\&quot; if VS alert text enabled.     CEEEvChannelAlertText: VS alert text.     CEEEvChannelNoticeEnabled: set \&quot;true\&quot; if channel notice enabled.      CEEEvChannelNoticeText: channel notice text.     CEEEvContentServerAlertEnabled: set \&quot;true\&quot; if real server alert text enabled.     CEEEvContentServerAlertText: real server alert text.     CEEEvContentServerNoticeEnabled:     CEEEvContentServerNoticeText:     CEEEvFlightPathEnabled: set \&quot;true\&quot; if flightpath notice enabled.      CEEEvFlightPathText: flightpath notice text.     CEEEvIpServiceAlertTextEnabled: set \&quot;true\&quot; if IP service alert text enabled.     CEEEvIpServiceAlertText: ip service alert text.     CEEEvIpServiceNoticeEnabled: set \&quot;true\&quot; if IP service notice enabled.      CEEEvIpServiceNoticeText: ip service notice text.     CEEGroupEnabled: set \&quot;true\&quot; if group notice enabled.      CEEGroupText: group notice text.     CEEGroupTime: group time. 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body Object that needs to be sent to the server
@return []EmaileventsAll
*/
func (a *EmailEventsApiService) POST17iAction1iType2Post(ctx context.Context, body NotificationEmailEvent) ([]EmaileventsAll, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []EmaileventsAll
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/POST/17?iAction=1&iType=2"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("GUID", key)
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []EmaileventsAll
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
EmailEventsApiService Warning details
This service is used to update warnings details, you have to send warnings details, with POST request json.    JSON that needs to be sent as request payload, Should contains given information-        CEEEvDiskSpaceEnabled: set \&quot;true\&quot; if disk space notice enabled.     CEEEvDiskSpaceText: disk space notice text.     CEEEvLicenceRenevalEnabled: set \&quot;true\&quot; if Licence Reneval notice enabled.     CEEEvLicenceRenevalText: Licence Reneval text.     CEEEvDiskSpacePercent: disk space percentage. 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body Object that needs to be sent to the server
 * @param iAction 1
 * @param iType 3
@return []EmaileventsAll
*/
func (a *EmailEventsApiService) POST17iAction1iType3Post(ctx context.Context, body WarningsEmailEvent, iAction float64, iType float64) ([]EmaileventsAll, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []EmaileventsAll
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/POST/17?iAction=1&iType=3"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("iAction", parameterToString(iAction, ""))
	localVarQueryParams.Add("iType", parameterToString(iType, ""))
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("GUID", key)
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []EmaileventsAll
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
EmailEventsApiService Test Break email event
This service is used to update email events detaiils, you have to send email events details, with POST request json.    JSON that needs to be sent as request payload, Should contains given information-        CEEAuthorisationRequired: set \&quot;true\&quot; if authorization required.     CEEEMailServerPassword: Mail server password.     CEELocalEmailAddress: E-Mail address.     CEEMailServer: Host Address.     CEEMailServerLogon: Mail server account name.     CEEPort: Port address.     CEERemoteEmailAddress: Email address for Send E-mail.     CEESecurity: security      CEETimeout: Timeout.     Test: set \&quot;true\&quot; if want to send test mail with update otherwise set \&quot;false\&quot; to only update. 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body Object that needs to be sent to the server
@return []EmaileventsAll
*/
func (a *EmailEventsApiService) POST17iAction2iType1Post(ctx context.Context, body UpdateEmailEvent) ([]EmaileventsAll, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []EmaileventsAll
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/POST/17?iAction=2&iType=1"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			
			localVarQueryParams.Add("GUID", key)
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []EmaileventsAll
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
